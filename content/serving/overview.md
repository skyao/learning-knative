---
date: 2018-10-24T14:25:00+08:00
title: 资源类型
weight: 310
menu:
  main:
    parent: "serving"
description : "资源类型"
---

> 备注: 内容来自 https://github.com/knative/serving/blob/master/docs/spec/overview.md

Knative Serving API中的主要资源是 Routes, Revisions, Configurations, 和 Services:

- **Route** 提供命名端点和机制来路由流量到
- **Revisions**, 修订版本是 `code + config` 的不可变快照, 通过
- **Configuration** 创建, 配置充当修订版本的环境流。
- **Service** 充当顶级容器，用于管理路由和配置的集合，实现网络服务。

![Object model](images/object_model.png)

## Route/路由

**Route**为用户的服务提供网络端点（其中包括一系列随时间推移的软件和配置修订版本）。 kubernetes命名空间可以有多个路由。路由提供了一个长期，稳定，已命名，HTTP可寻址的端点，该端点由一个或多个**Revision**支持。路由的默认配置是自动将流量路由到**Configuration**创建的最新修订版本。对于更复杂的场景，API支持按百分比流量拆分，而CI工具可以维护单个路由的多个配置（例如“golden path/黄金路径”和“experiments/实验”），或者在增量部署期间直接引用多个修订版本到固定版本，还有多路流量拆分。路由可以有选择地将可寻址子域名分配给任何或所有后备修订版本。

## Revision/修订版本

**Revision**是代码和配置的不可变快照。修订版本引用容器镜像，以及可选的Build，这个build负责从source开始物化为容器镜像。通过对**Configuration**的更新来创建修订版本。

无法通过路由寻址的修订版本将被淘汰，并且所有底层K8资源将被删除。这提供了随时间推移配置产生的修订版本的轻量级历史记录，并使用户能够轻松回滚到先前的修订版。

可通过路由寻址的修订版本将使资源利用率与它们所承受的负载成比例。

## Configuration/配置

**Configuration**描述了所需的最新修订版本状态，并在所需状态被更新时创建并跟踪修订版本的状态。配置可能包括有关如何通过引用Build将source包（git 仓库或打包）转换为容器的说明，或者可能只是引用修订版本所需的容器镜像和关联的执行元数据。在对配置的更新时，可以执行新的build和/或部署（创建修订版本）; 配置控制器将跟踪创建的修订版本的状态，并使最近创建的和最近准备好的（即健康的）修订版本在状态部分中可用。

## Service/服务

**Service**封装了一组**Route**和**Configuration**，它们共同提供软件组件。存在提供单一抽象的服务，该抽象可以是访问控制，推理，并且封装软件生命周期决策，例如推出策略和团队资源所有权。服务仅充当底层路由和配置的编排器（就像kubernetes Deployment 编排 ReplicaSets 一样），其使用是可选的，但推荐使用。

服务的控制器将跟踪其拥有的配置和路由的状态，反映其状态和条件。

拥有的Configurations的Ready条件表现为Service的ConfigurationsReady条件。拥有的路由的Ready条件表现为服务的RoutesReady条件。

## Orchestration/编排

系统将配置为禁止用户创建([NYI](https://github.com/knative/serving/issues/664)) 或更改修订。取而代之的是，在创建或更新配置时间接创建修订版本。 这提供：

- 单个可引用资源，用于让路由执行自动化部署
- 可以监视的单个资源，以查看创建的所有修订版本的历史记录
- 服务器端实现的修订版本的PATCH语义，最小化跨多个客户端实现的读取-修改-写入，这可能导致乐观并发错误
- 回滚到已知正常配置的能力

在传统的单一实时修订版本方案中，服务创建与服务同名的路由和配置。服务的更新操作有如下场景：

- *"推送代码，保持配置":* 使用已更新的source指定新的修订版本，从配置（例如环境变量中）继承配置。
- *"更新配置，保持代码"*: 将新修订版本指定为配置更改，例如更新环境变量，继承所有其他配置和source/镜像。
- *"执行手工推出"*: 在固定推出模式下更新服务允许在开始之前手动测试修订版本。

使用Service对象来编排路由和配置的创建，可以让代码的部署（例如，从github按钮）避免需要推断并行资源创建的排序和失败模式。